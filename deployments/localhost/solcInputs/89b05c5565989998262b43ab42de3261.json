{
  "language": "Solidity",
  "sources": {
    "contracts/DoctorType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n\nlibrary DoctorType {\n    //Type Declaration\n    struct Doctor {\n        address doctorAddress; //account address of doctor\n        string name;\n        string doctorRegistrationId; //NMC Regsitration Id\n        uint256 dateOfRegistration;\n        string specialization;\n        address hospitalAddress;\n    }\n}"
    },
    "contracts/PatientMedicalRecordSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n/// @title A smart contract supporting the Decentralized Patient Medical Record System\n/// @author Aditya Kumar Singh @ July 2022\n/// @notice This smart contract is a part of my 2nd Year Summer Project\n/// @dev All function calls are currently implemented without side effects\n\n//imports\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {DoctorType} from \"./DoctorType.sol\";\nimport {HospitalType} from \"./HospitalType.sol\";\nimport {PatientType} from \"./PatientType.sol\";\n\n//errors\nerror PatientMedicalRecords__NotOwner();\nerror PatientMedicalRecords__NotDoctor();\nerror PatientMedicalRecords__NotApproved();\nerror PatientMedicalRecords__NotPatient();\n\ncontract PatientMedicalRecordSystem is ReentrancyGuard {\n    //Type Declaration\n\n    //Storage Variables\n    mapping(address => PatientType.Patient) private s_patients;\n    mapping(address => DoctorType.Doctor) private s_doctors;\n    mapping(address => HospitalType.Hospital) private s_hospitals;\n    mapping(address => string) private s_addressToPublicKey;\n\n    address private immutable i_owner;\n\n    //Events\n    event AddedPatient(\n        address indexed patientAddress,\n        string name,\n        string[] chronicHash,\n        uint256 indexed dob,\n        string bloodGroup,\n        uint256 indexed dateOfRegistration,\n        string publicKey,\n        string[] vaccinationHash,\n        string phoneNumber,\n        string[] accidentHash,\n        string[] acuteHash\n    ); //added or modified\n\n    event AddedPublicKey(address indexed patientAddress, string publicKey); //emitting when public key is added.\n\n    event AddedDoctor(\n        address indexed doctorAddress,\n        string name,\n        string doctorRegistrationId,\n        uint256 indexed dateOfRegistration,\n        string specialization,\n        address indexed hospitalAddress\n    ); //added or modified to the mapping\n    event AddedHospital(\n        address indexed hospitalAddress,\n        string name,\n        string hospitalRegistrationId,\n        uint256 indexed dateOfRegistration,\n        string email,\n        string phoneNumber\n    ); //added(mostly) or modified\n\n    //modifiers\n    modifier onlyOwner() {\n        if (msg.sender != i_owner) {\n            revert PatientMedicalRecords__NotOwner();\n        }\n        _;\n    }\n\n    modifier onlyDoctor(address senderAddress) {\n        if (s_doctors[senderAddress].doctorAddress != senderAddress) {\n            revert PatientMedicalRecords__NotDoctor();\n        }\n        _;\n    }\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    //Functions\n    //patients can themselves register to the system.\n    function registerPatient(\n        address _patientAddress,\n        string memory _name,\n        uint256 _dob,\n        string memory _phoneNumber,\n        string memory _bloodGroup,\n        string memory _publicKey\n    ) external nonReentrant {\n        if (msg.sender != _patientAddress) {\n            revert PatientMedicalRecords__NotPatient();\n        }\n        PatientType.Patient memory patient;\n        patient.name = _name;\n        patient.patientAddress = _patientAddress;\n        patient.dob = _dob;\n        patient.phoneNumber = _phoneNumber;\n        patient.bloodGroup = _bloodGroup;\n        patient.dateOfRegistration = block.timestamp;\n        patient.publicKey = _publicKey; //public key is stored here.\n\n        patient.vaccinationHash = new string[](0); //0\n        patient.accidentHash = new string[](0); // 1\n        patient.chronicHash = new string[](0); //2\n        patient.acuteHash = new string[](0); //3\n\n        s_patients[_patientAddress] = patient;\n        s_addressToPublicKey[_patientAddress] = _publicKey;\n\n        //emiting the events\n        emit AddedPublicKey(_patientAddress, _publicKey);\n        emit AddedPatient(\n            _patientAddress,\n            patient.name,\n            patient.chronicHash,\n            patient.dob,\n            patient.bloodGroup,\n            patient.dateOfRegistration,\n            patient.publicKey,\n            patient.vaccinationHash,\n            patient.phoneNumber,\n            patient.accidentHash,\n            patient.acuteHash\n        );\n    }\n\n    function addPatientDetails(\n        address _patientAddress,\n        uint16 _category,\n        string memory _IpfsHash //This is the IPFS hash of the diagnostic report which contains an IPFS file hash (preferably PDF file)\n    ) external onlyDoctor(msg.sender) nonReentrant \n    {\n        if (_category == 0) {\n            s_patients[_patientAddress].vaccinationHash.push(_IpfsHash);\n        } else if (_category == 1) {\n            s_patients[_patientAddress].accidentHash.push(_IpfsHash);\n        } else if (_category == 2) {\n            s_patients[_patientAddress].chronicHash.push(_IpfsHash);\n        } else if (_category == 3) {\n            s_patients[_patientAddress].acuteHash.push(_IpfsHash);\n        }\n        PatientType.Patient memory patient = s_patients[_patientAddress];\n        //emitting the event.\n        emit AddedPatient(\n            _patientAddress,\n            patient.name,\n            patient.chronicHash,\n            patient.dob,\n            patient.bloodGroup,\n            patient.dateOfRegistration,\n            patient.publicKey,\n            patient.vaccinationHash,\n            patient.phoneNumber,\n            patient.accidentHash,\n            patient.acuteHash\n        );\n    }\n\n    //this will be done using script by the owner\n    function addDoctorDetails(\n        address _doctorAddress,\n        string memory _name,\n        string memory _doctorRegistrationId,\n        uint256 _dateOfRegistration,\n        string memory _specialization,\n        address _hospitalAddress\n    ) external onlyOwner nonReentrant {\n        DoctorType.Doctor memory doctor;\n        doctor.name = _name;\n        doctor.doctorRegistrationId = _doctorRegistrationId;\n        doctor.doctorAddress = _doctorAddress;\n        doctor.dateOfRegistration = _dateOfRegistration;\n        doctor.specialization = _specialization;\n        doctor.hospitalAddress = _hospitalAddress;\n        s_doctors[_doctorAddress] = doctor;\n        //emitting the event.\n        emit AddedDoctor(\n            _doctorAddress,\n            doctor.name,\n            doctor.doctorRegistrationId,\n            doctor.dateOfRegistration,\n            doctor.specialization,\n            doctor.hospitalAddress\n        );\n    }\n\n    //this will be done using script by the owner\n    function addHospitalDetails(\n        address _hospitalAddress,\n        string memory _name,\n        string memory _hospitalRegistrationId,\n        string memory _email,\n        string memory _phoneNumber\n    ) external onlyOwner nonReentrant {\n        HospitalType.Hospital memory hospital = s_hospitals[_hospitalAddress];\n        hospital.hospitalAddress = _hospitalAddress;\n        hospital.name = _name;\n        hospital.email = _email;\n        hospital.phoneNumber = _phoneNumber;\n        hospital.hospitalRegistrationId = _hospitalRegistrationId;\n        hospital.dateOfRegistration = block.timestamp;\n        s_hospitals[_hospitalAddress] = hospital;\n        //emitting the event.\n        emit AddedHospital(\n            hospital.hospitalAddress,\n            hospital.name,\n            hospital.hospitalRegistrationId,\n            hospital.dateOfRegistration,\n            hospital.email,\n            hospital.phoneNumber\n        );\n    }\n\n    function getMyDetails() external view returns (PatientType.Patient memory) {\n        return s_patients[msg.sender];\n    }\n\n    //authorized doctor viewing patient's records\n    function getPatientDetails(address _patientAddress)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            uint256\n        )\n    {\n        return (\n            s_patients[_patientAddress].name,\n            s_patients[_patientAddress].publicKey,\n            s_patients[_patientAddress].dateOfRegistration\n        );\n    }\n\n    function getPublicKey(address _patientAddress) public view returns (string memory) {\n        return s_addressToPublicKey[_patientAddress];\n    }\n\n    function getDoctorDetails(address _doctorAddress)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            string memory,\n            address\n        )\n    {\n        return (\n            s_doctors[_doctorAddress].name,\n            s_doctors[_doctorAddress].specialization,\n            s_doctors[_doctorAddress].doctorRegistrationId,\n            s_doctors[_doctorAddress].hospitalAddress\n        );\n    }\n\n    function getHospitalDetails(address _hospitalAddress)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            string memory\n        )\n    {\n        return (\n            s_hospitals[_hospitalAddress].name,\n            s_hospitals[_hospitalAddress].hospitalRegistrationId,\n            s_hospitals[_hospitalAddress].email\n        );\n    }\n\n    function getOwner() external view returns (address) {\n        return i_owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/HospitalType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nlibrary HospitalType{\n    //Type Declaration\n\n    struct Hospital{\n        string name;\n        address hospitalAddress; //account address of hospital\n        uint256 dateOfRegistration;\n        string hospitalRegistrationId;\n        string email;\n        string phoneNumber;\n    }\n}"
    },
    "contracts/PatientType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n\nlibrary PatientType {\n    //Type Declaration\n    struct Patient {\n        string name;        //   \n        address patientAddress; //account address of patient     \n        uint256 dob;      //\n        string phoneNumber;\n        string bloodGroup;     //\n        string publicKey;      //for storing public key for encrypting the data\n        uint256 dateOfRegistration; //the date of registration of patient to the system. Tells which records are not in the system.\n        //Medical Records\n        string[] vaccinationHash; //0\n        string[] accidentHash; // 1\n        string[] chronicHash; //2\n        string[] acuteHash; //3\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}